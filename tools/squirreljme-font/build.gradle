import cc.squirreljme.plugin.tasks.MimeDecodeResourcesTask
import cc.squirreljme.plugin.util.GradleLoggerOutputStream
import cc.squirreljme.plugin.util.JavaExecSpecFiller
import cc.squirreljme.plugin.util.SimpleJavaExecSpecFiller
import lombok.Getter

import javax.inject.Inject
import java.nio.file.Files

plugins {
	id "java"
	id "application"
}

apply plugin: "com.github.johnrengelman.shadow"

description = "SquirrelJME Font Compiler."
mainClassName = "cc.squirreljme.fontcompile.Main"

tasks.register("mimeDecode", MimeDecodeResourcesTask.class,
	"main",
	tasks.named("processResources").get(),
	tasks.named("clean").get())

processResources.dependsOn("mimeDecode")
jar.dependsOn("mimeDecode")

dependencies {
	implementation project(":emulators:emulator-base")
	implementation project(":modules:cldc-compact")
	implementation project(":modules:io")
	
	// Lombok for simpler getters/setters
	implementation 'org.projectlombok:lombok:1.18.30'
	annotationProcessor 'org.projectlombok:lombok:1.18.30'
}

class CompileFontTask extends DefaultTask {
	/** The font path. */
	@Getter
	@Internal
	final java.nio.file.Path fontPath
	
	/** The output path. */
	@Getter
	@Internal
	final java.nio.file.Path compiledPath
	
	@Inject
	public CompileFontTask(String __pathy, String __outName) {
		if (__pathy == null || __outName == null) {
			throw new NullPointerException("No path.")
		}
		
		this.group = "squirreljme"
		this.description = "Compiles font ${__pathy}."
		
		// We need the actual program first
		Provider<Task> shadowTask = this.project.provider({ ->
			this.project.tasks.getByName("shadowJar")})
		this.dependsOn(shadowTask)
		
		// Determine where the font is
		java.nio.file.Path fontPath = this.project.rootProject.rootDir
			.toPath().resolve("assets").resolve("font").resolve(__pathy)
		this.fontPath = fontPath
		
		// Where does this go?
		java.nio.file.Path compiledPath = this.project.buildDir.toPath()
			.resolve("fonts").resolve(__outName + ".sqf")
		this.compiledPath = compiledPath
		
		// Make the shadow Jar input for the task just to make sure that
		// is up to date!
		this.inputs.file(this.project.provider({ ->
			shadowTask.get().outputs.files.singleFile}))
		
		// Set font data as input
		if (Files.isDirectory(fontPath)) {
			this.inputs.dir(fontPath)
		} else {
			this.inputs.file(fontPath)
		}
		
		// Compiled output is an output for this
		this.outputs.file(compiledPath)
		
		this.doFirst({Task tasky ->
			// Setup task for execution
			ExecResult exitResult = tasky.project.javaexec(
				{ JavaExecSpec spec ->
					// Use the output Jar
					spec.classpath(
						shadowTask.get().outputs.files.singleFile)
					spec.main("cc.squirreljme.fontcompile.Main")
					
					// Input and output
					spec.args(fontPath.toAbsolutePath().toString(),
						compiledPath.toAbsolutePath().toString())
					
					// Use these streams directly
					spec.setStandardOutput(new GradleLoggerOutputStream(
						tasky.getLogger(), LogLevel.LIFECYCLE,
						-1, -1))
					spec.setErrorOutput(new GradleLoggerOutputStream(
						tasky.getLogger(), LogLevel.ERROR,
						-1, -1))
				})
			
			// Did the task fail?
			int exitValue = exitResult.getExitValue()
			if (exitValue != 0)
				throw new RuntimeException("Task exited with: " + exitValue)
		})
	}
}

// Generic task to compile all fonts
TaskProvider<Task> compileFonts = tasks.register("compileFonts") {
	this.group = "squirreljme"
	this.description = "Compiles all fonts."
}

for (String fn in [
	"monospace.sfdir/8.strike",
	"monospace.sfdir/16.strike",
	"monospace.sfdir/24.strike",
	"sansserif.sfdir/8.strike",
	"sansserif.sfdir/16.strike",
	"sansserif.sfdir/24.strike",
	"serif.sfdir/8.strike",
	"serif.sfdir/16.strike",
	"serif.sfdir/24.strike",
	"misaki8.bdf",
	"misaki12.bdf",
	"unifont16.bdf",
	"unifont-upper16.bdf"]) {
	// Determine a better name for it
	String shortish = fn.substring(0, 1).toUpperCase() + fn.replaceAll(
		"(\\.sfdir|\\.strike|\\.bdf|/)", "").substring(1)
	
	// Register it
	TaskProvider<Task> compileFont = tasks.register("compileFont${shortish}",
		CompileFontTask.class,
		fn, shortish.toLowerCase(Locale.ROOT))
	
	// Include in compilation of all fonts
	compileFonts.get().dependsOn(compileFont)
}
