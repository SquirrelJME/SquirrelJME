// -*- Mode: Java; indent-tabs-mode: t; tab-width: 4 -*-
// ---------------------------------------------------------------------------
// Multi-Phasic Applications: SquirrelJME
//     Copyright (C) Stephanie Gawroriski <xer@multiphasicapps.net>
// ---------------------------------------------------------------------------
// SquirrelJME is under the Mozilla Public License Version 2.0.
// See license.mkd for licensing and copyright information.
// ---------------------------------------------------------------------------

package cc.squirreljme.profiler;

import cc.squirreljme.runtime.cldc.util.StreamUtils;
import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintStream;
import java.util.Date;
import java.util.Map;
import net.multiphasicapps.io.ZLibCompressor;

/**
 * Implements writing of VisualVPM {@code .nps} files.
 *
 * @since 2023/08/19
 */
public class VisualVMWriter
	implements SnapshotWriter
{
	/** The stream to write to. */
	protected final DataOutputStream out;
	
	/** The snapshot to write to. */
	protected final ProfilerSnapshot snapshot;
	
	/**
	 * Initializes the VisualVM Writer.
	 *
	 * @param __snapshot The snapshot to write to.
	 * @param __out The stream to write to.
	 * @throws NullPointerException On null arguments.
	 * @since 2023/08/19
	 */
	public VisualVMWriter(ProfilerSnapshot __snapshot, OutputStream __out)
		throws NullPointerException
	{
		if (__out == null || __snapshot == null)
			throw new NullPointerException("NARG");
		
		// We always want a data output stream here for binary data
		if (__out instanceof DataOutputStream)
			this.out = (DataOutputStream)__out;
		else
			this.out = new DataOutputStream(__out);
		
		this.snapshot = __snapshot;
	}
	
	/**
	 * {@inheritDoc}
	 * @since 2023/08/19
	 */
	@Override
	public void write()
		throws IOException
	{
		ProfilerSnapshot snapshot = this.snapshot;
		
		// We write to this because we need the data
		DataOutputStream cont = new DataOutputStream(this.out);
		
		// Magic number
		cont.writeBytes("nBpRoFiLeR");
		
		// Version
		cont.write(1);
		cont.write(2);
		
		// Type
		cont.writeInt(1);
		
		// Write compressed snapshot data to the byte array
		try (ByteArrayOutputStream baos = new ByteArrayOutputStream(2048))
		{
			// Compress the CPU data
			ZLibCompressor olddefl;
			try (ZLibCompressor defl = new ZLibCompressor(baos);
				DataOutputStream cpu = new DataOutputStream(defl))
			{
				// Used to get compressed size and such
				olddefl = defl;
				
				// Write header
				cpu.writeInt(1);
				
				// Timestamp and duration
				cpu.writeLong(snapshot.startmillis);
				
				// Threads are needed now
				Map<String, ProfiledThread> threads = snapshot._threads;
				synchronized (threads)
				{
					// The duration of the trace is the maximum time any
					// thread has spent
					long maxtime = 0;
					for (ProfiledThread t : threads.values())
						maxtime = Math.max(maxtime, t._totalTime);
					cpu.writeLong(maxtime);
					
					// Thread time is always measured
					cpu.writeBoolean(true);
					
					// Build and write the instrumented method table
					Map<FrameLocation, Integer> mids =
						snapshot.__doMethodTable();
					cpu.writeInt(mids.size());
					for (FrameLocation loc : mids.keySet())
					{
						cpu.writeUTF(loc.inclass);
						cpu.writeUTF(loc.methodname);
						cpu.writeUTF(loc.methodtype);
					}
				
					// Write thread data
					cpu.writeInt(threads.size());
				
					// Write individual thread
					for (ProfiledThread t : threads.values())
						this.__doWriteThread(cpu, t, mids);
				}
			}
			
			// Store sizes, which are important
			cont.writeInt(baos.size());
			cont.writeInt((int)Math.min(Integer.MAX_VALUE,
				olddefl.uncompressedBytes()));
			
			// Store the compressed data
			baos.writeTo(cont);
		}
		
		// Write properties of the snapshot
		try (ByteArrayOutputStream baos = new ByteArrayOutputStream(
			StreamUtils.bufferSize(null)))
		{
			// Write them all
			try (PrintStream ps = new PrintStream(baos, true))
			{
				// Make sure it is flushed
				ps.flush();
			}
			
			// Store data
			cont.writeInt(baos.size());
			baos.writeTo(cont);
		}
		
		// Write comment
		cont.writeUTF("Generated by SquirrelJME " +
			"<https://multiphasicapps.net/>\n" +
			"Copyright (C) Stephanie Gawroriski 2016-2019\n" +
			"\n" +
			"Record date: " + new Date());
		
		// Make sure everything is flushed
		cont.flush();
	}
	
	/**
	 * Writes the thread information to the stream.
	 *
	 * @param __cpu The stream to write to.
	 * @param __t The thread information to write.
	 * @param __mids The method IDs.
	 * @throws IOException On write errors.
	 * @throws NullPointerException On null arguments.
	 * @since 2018/11/11
	 */
	private void __doWriteThread(DataOutputStream __cpu,
		ProfiledThread __t, Map<FrameLocation, Integer> __mids)
		throws IOException, NullPointerException
	{
		if (__cpu == null || __t == null || __mids == null)
			throw new NullPointerException("NARG");
		
		// ID and name
		__cpu.writeInt(__t.name.hashCode());
		__cpu.writeUTF(__t.name);
		
		// Always measure thread time
		__cpu.writeBoolean(true);
		
		// Parse the node table for this thread
		__NodeTable__ nodes = new __NodeTable__();
		nodes.parseThread(__t);
		
		// Write the node table
		try (ByteArrayOutputStream baos = new ByteArrayOutputStream(1024))
		{
			// Write to the temporary buffer
			nodes.writeTo(baos, __mids);
			
			// Store the node table
			__cpu.writeInt(baos.size());
			baos.writeTo(__cpu);
		}
		
		// Node size is always 28
		__cpu.writeInt(28);
		
		// Whole graph time
		__cpu.writeLong(__t._totalTime);
		__cpu.writeLong(__t._cpuTime);
		
		// No injected methods used
		__cpu.writeLong(0);
		__cpu.writeLong(0);
		
		// Pure time (always seems to be max value)
		__cpu.writeLong(Integer.MAX_VALUE);
		__cpu.writeLong(Integer.MAX_VALUE);
		
		// Net time?
		__cpu.writeLong(__t._totalTime);
		__cpu.writeLong(__t._cpuTime);
		
		// The number of methods invoked
		__cpu.writeLong(__t._invtotal);
		
		// Always display CPU time
		__cpu.writeBoolean(true);
	}
}
