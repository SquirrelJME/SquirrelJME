# 2016/08/11

## 07:22

What I will need is an object format for the generic namespace blobs.

## 07:26

I could use standard ELFs with relocations, however the blobs would not be
directly ROM executable and such. So I suppose what I can do is have the code
and data treads placed in the file and the table of contents placed at the end.
There would be one for classes and another for resources. Although it may be
possible to have relocations and not have them at the same time. Relocations
could be useful for the end linking process into the SquirrelJME binary.

## 12:28

I received the Creator CI40 today, so this will be an interesting device to
develop for.

	# uname -a
	Linux OpenWrt 4.1.13 #1 SMP Tue Jul 26 02:49:14 UTC 2016 mips GNU/Linux
	
	# cat /proc/cpuinfo
	system type             : IMG Pistachio SoC (B0)
	machine                 : IMG Marduk - Ci40 with ca8210
	processor               : 0
	cpu model               : MIPS interAptiv (multi) V2.0  FPU V0.0
	BogoMIPS                : 363.72
	wait instruction        : yes
	microsecond timers      : yes
	tlb_entries             : 64
	extra interrupt vector  : yes
	hardware watchpoint     : yes, count: 4, address/irw mask: [0x0ffc, 0x0ffc,
	0x0ffb, 0x0ffb]
	isa                     : mips1 mips2 mips32r1 mips32r2
	ASEs implemented        : mips16 dsp mt eva
	shadow register sets    : 1
	kscratch registers      : 0
	package                 : 0
	core                    : 0
	VCED exceptions         : not available
	VCEI exceptions         : not available
	VPE                     : 0

	processor               : 1
	cpu model               : MIPS interAptiv (multi) V2.0  FPU V0.0
	BogoMIPS                : 272.79
	wait instruction        : yes
	microsecond timers      : yes
	tlb_entries             : 64
	extra interrupt vector  : yes
	hardware watchpoint     : yes, count: 4, address/irw mask: [0x0ffc, 0x0ffc,
	0x0ffb, 0x0ffb]
	isa                     : mips1 mips2 mips32r1 mips32r2
	ASEs implemented        : mips16 dsp mt eva
	shadow register sets    : 1
	kscratch registers      : 0
	package                 : 0
	core                    : 0
	VCED exceptions         : not available
	VCEI exceptions         : not available
	VPE                     : 1

	processor               : 2
	cpu model               : MIPS interAptiv (multi) V2.0  FPU V0.0
	BogoMIPS                : 363.72
	wait instruction        : yes
	microsecond timers      : yes
	tlb_entries             : 64
	extra interrupt vector  : yes
	hardware watchpoint     : yes, count: 4, address/irw mask: [0x0ffc, 0x0ffc,
	0x0ffb, 0x0ffb]
	isa                     : mips1 mips2 mips32r1 mips32r2
	ASEs implemented        : mips16 dsp mt eva
	shadow register sets    : 1
	kscratch registers      : 0
	package                 : 0
	core                    : 1
	VCED exceptions         : not available
	VCEI exceptions         : not available
	VPE                     : 0

	processor               : 3
	cpu model               : MIPS interAptiv (multi) V2.0  FPU V0.0
	BogoMIPS                : 363.72
	wait instruction        : yes
	microsecond timers      : yes
	tlb_entries             : 64
	extra interrupt vector  : yes
	hardware watchpoint     : yes, count: 4, address/irw mask: [0x0ffc, 0x0ffc,
	0x0ffb, 0x0ffb]
	isa                     : mips1 mips2 mips32r1 mips32r2
	ASEs implemented        : mips16 dsp mt eva
	shadow register sets    : 1
	kscratch registers      : 0
	package                 : 0
	core                    : 1
	VCED exceptions         : not available
	VCEI exceptions         : not available
	VPE                     : 1
	
	# free -m
		         total       used       free     shared    buffers     cached
	Mem:        185380      34200     151180         84          0       6888
	-/+ buffers/cache:      27312     158068
	Swap:            0          0          0

Going to install a Debian chroot since there currently is no Linux kernel
available.

## 15:11 When

I should probably support reading the blob format before I write it, so I can
have a clue as to how to write it out.

## 18:17

Appears the CPU on the device does not support denormal floating point
operations, which is totally reasonable, and that the Linux kernel is not
emulating these. I will need to make a note of this and have an illegal
instruction handler for some CPUs to emulate operations on denormals so that
even though they are not implemented by the CPU, the host code can still run.

## 19:56

I do wonder though if there is an extremely low memory way of writing that is
not a complete mess and is quick to parse while also having some sense of
security. I would like things done in a single pass. What if everything was
a native method, including the class definitions. I really just need code and
resources. However they should not be together at all, since if there is a
breach then data could be executed as code (which would be very bad).

## 20:06

That actually could be something. Instead of having it where there is just
static data that is handled by an object format reader, instead each namespace
has an entry initialization. Basically this would be generated machine code
that when called will setup the namespace as it should be setup on the running
VM. Everything would essentially be executable for the most part. When a
namespace is desired to be used then its boot code is used which registers
everything. However this code will be shared among all namespaces for the most
part. When namespaces are read, there will need to be linear scan of
everything anyway. The only issue would be determining the size of entries
before they are written and actually known (unless `ZipFile` is used, but
every entry is treated as a stream of bytes anyway). When a classpath is
initialized, the namespace should be scanned and then code linked in as such
and classes registered as needed.

