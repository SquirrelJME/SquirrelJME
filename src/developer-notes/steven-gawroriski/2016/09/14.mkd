# 2016/09/14

## 07:19

Thinking that the input class and the JIT class are not checked to make sure
that they are the same. But classes are only started when their name is known.

## 07:37

One thing I could do is have a field table of sorts. Basically similar to
the class and resource table except that there is a linear table of field
information. Then the class refers to a range in this table. The same could
be done for methods. This way fields and methods do not have to be referenced
by pointers. This would mean that I could allow classes to be slightly larger
in size becuase I do not need pointers for all of the data. Fields do not
need any pointer data at all, however methods do for code. So I could
essentially keep the class a bit more compact and possibly a bit easier to
parse. This also means that readers for class information can have a single
`List` of fields that could have a cached representation. So this could
work out very well.

## 07:53

The same could be said for interfaces also. I would need 6 bytes for large
classes, but with a single table I only need to use 4.

## 08:55

The interface can be used also to quickly verify and actually in a way link
interfaces. So basically at link time, I can scan the entire list and lookup
classes to determine if they are actual interfaces. Then I would not need to
check it when I load the class table. Each interface in the interface table
could also have a run-time class representation binding.

## 12:05

The extended data output streams could use exact versions of writing signed
and unsigned type values, at least for `byte` and `short`.

## 12:08

I can also have the same tables for method code too, this way code exists in
a single table. When it comes to exception handling it could also be in the
code table, so if a piece of code has an exception handler then it could just
point to a code table index.

