import cc.squirreljme.plugin.general.CollateResourceJarsTask
import cc.squirreljme.plugin.multivm.*
import cc.squirreljme.plugin.multivm.ident.SourceTargetClassifier

import java.util.regex.Pattern

plugins
{
	id "application"
	id "java"
}

apply plugin: "com.github.johnrengelman.shadow"

description = "Standalone SquirrelJME virtual machine on Java."
mainClassName = "cc.squirreljme.vm.standalone.main.Main"

dependencies {
	implementation project(":emulators:springcoat-vm")
	implementation project(":emulators:nanocoat-vm")
	
	// Debugger tool for quick usage
	implementation project(":tools:squirreljme-debugger")
}

java {
	// Use a fixed version of the JVM
	compileJava
	{
		sourceCompatibility = JavaVersion.VERSION_1_8
		targetCompatibility = JavaVersion.VERSION_1_8
		
		// Use the default bootstrap classpath
		options.bootstrapClasspath = null
		
	}
	
	// Maximize debugging
	compileJava.options.debug = true
	compileJava.options.debugOptions.setDebugLevel("source,lines,vars")
	
	// Copy settings
	compileTestJava.options.debug = compileJava.options.debug
	compileTestJava.options.debugOptions = compileJava.options.debugOptions
}

// Mapper for Jar names on files to straight file names
static Iterable<java.nio.file.Path> mapBaseNameP(Iterable<Path> input) {
	List<java.nio.file.Path> result = new ArrayList<>()
	
	input.forEach({path -> result.add(path.getFileName())})
	
	return result;
}

static String flatClasspath(Project project) {
	return VMHelpers.classpathAsString(mapBaseNameP(VMHelpers
		.runClassPath(project, new SourceTargetClassifier(
			SourceSet.MAIN_SOURCE_SET_NAME,
			VMType.SPRINGCOAT, BangletVariant.NONE,
			ClutterLevel.RELEASE)) as List<Path>))
}

String MERGED_PREFIX = "SQUIRRELJME.SQC"
String MERGED_PREFIX_DEBUG = "SQUIRRELJME-DEBUG.SQC"

tasks.register("collateResourceJars",
	CollateResourceJarsTask.class,
	processResources, ClutterLevel.RELEASE, MERGED_PREFIX)
tasks.register("collateResourceJarsDebug",
	CollateResourceJarsTask.class,
	processResources, ClutterLevel.DEBUG, MERGED_PREFIX_DEBUG)

// Jar Configuration
jar {
	dependsOn processResources, collateResourceJars, collateResourceJarsDebug
	mustRunAfter collateResourceJars, collateResourceJarsDebug
	
	// We need to set specific manifest properties
	manifest {
		attributes \
			"X-SquirrelJME-Standalone-Main-Class":
				"javax.microedition.midlet.__MainHandler__",
			"X-SquirrelJME-Standalone-Parameter":
				"cc.squirreljme.runtime.launcher.ui.MidletMain",
			"X-SquirrelJME-Standalone-Classpath": project.provider({ ->
					return flatClasspath(project(":modules:launcher"))
				}),
			"X-SquirrelJME-Standalone-Library": project.provider({ ->
					return VMHelpers.classpathAsString(
						mapBaseNameP(VMHelpers.fullSuiteLibraries(
							rootProject.tasks.getByName("fullSpringCoatRelease"))
							as Iterable<Path>))
				}),
			"X-SquirrelJME-Standalone-Internal-Jar-Root": project.provider({ ->
				"/" + MERGED_PREFIX + "/"}),
			"X-SquirrelJME-Standalone-Internal-Debug-Jar-Root": project.provider({ ->
				"/" + MERGED_PREFIX_DEBUG + "/"})
	}
}

// Configuration for ShadowJar
shadowJar {
	dependsOn collateResourceJars, collateResourceJarsDebug
	mustRunAfter collateResourceJars, collateResourceJarsDebug
	
	// Always SquirrelJME
	archiveBaseName.set("squirreljme-standalone")
	
	// Always merge service files, otherwise multiple VMs will just not work
	mergeServiceFiles()
	
	// Set the suffix of the JAR to be the OS name and arch, since there is
	// a dynamic library within for it
	archiveClassifier.set(project.provider({ ->
			String osName = System.getProperty("os.name").toLowerCase()
			String osArch = System.getProperty("os.arch").toLowerCase()
			
			// Normalize OS names
			if (osName.contains("windows"))
				osName = "windows"
			else if (osName.contains("mac os") || osName.contains("macos"))
				osName = "macos"
			
			// Make sure there are no spaces or weird characters such as for
			// Windows
			return (osName + "-" + osArch).replaceAll(
				Pattern.compile("[\\s<>:\"/\\\\|?*]"), "") 
		}))
	
	// Exclude IntelliJ Annotations, they are not needed
	exclude "org/jetbrains/annotations/*.class"
	exclude "org/intellij/lang/annotations/*.class"
	
	dependencies {
		// Exclude IntelliJ Annotations, they are not needed
		exclude(dependency("org.jetbrains:annotations-java5:.*"))
	}
}

/**
 * Fills the execution specification.
 * 
 * @param __exec The specification to fill.
 * @param __emulator The emulator to use.
 * @param __isCluttered Is this cluttered?
 * @param __isDebug Is this debugging?
 * @since 2024/06/25
 */
void __fillSpec(JavaExec __exec, VMType __emulator, boolean __isCluttered,
	boolean __isDebug) {
	// These are always the same
	__exec.classpath(project.providers.provider {
		tasks.named("shadowJar").get().getOutputs().getFiles()})
	__exec.mainClass = "cc.squirreljme.vm.standalone.main.Main"
	
	// Build arguments to use
	List<String> args = new ArrayList<>()
	
	// Which emulator is used?
	args += ("-Xemulator:" + __emulator.vmName(VMNameFormat.LOWERCASE))
	
	// Cluttered?
	if (__isCluttered) {
		args += "-Xclutter:debug"
	}
	
	// Debugging?
	if (__isDebug) {
		args += "-Xdebug"
	}
	
	// Use these args
	__exec.args = args
}

// Shadow run tasks for the various emulator choices
[false, true].each { isDebug ->
	[false, true].each { isCluttered ->
		VMType.values().each { vmType ->
			tasks.register("run" + vmType.vmName(VMNameFormat.PROPER_NOUN) +
					(isDebug ? "Debug" : "") +
					(isCluttered ? "Cluttered" : ""),
				JavaExec) { sub ->
				sub.dependsOn tasks.named("shadowJar")
	
				sub.description = "Runs the standalone VM via " +
					"${vmType.properName}" +
					(isDebug ? " with debugging" : "") +
					(isCluttered ? " with cluttering" : "") + ".";
				sub.group = "squirreljme"
				
				// Use simplified filler
				__fillSpec(sub, vmType, isCluttered, isDebug)
			}
		}
	}
}
