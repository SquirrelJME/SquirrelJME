// -*- Mode: Java; indent-tabs-mode: t; tab-width: 4 -*-
// ---------------------------------------------------------------------------
// Multi-Phasic Applications: SquirrelJME
//     Copyright (C) 2013-2016 Steven Gawroriski <steven@multiphasicapps.net>
//     Copyright (C) 2013-2016 Multi-Phasic Applications <multiphasicapps.net>
// ---------------------------------------------------------------------------
// SquirrelJME is under the GNU General Public License v3+, or later.
// For more information see license.mkd.
// ---------------------------------------------------------------------------

package net.multiphasicapps.doclet.markdown;

import com.sun.javadoc.ClassDoc;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.nio.channels.Channels;
import java.nio.channels.FileChannel;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Set;
import net.multiphasicapps.doclet.CommondocClass;
import net.multiphasicapps.doclet.CommondocMain;
import net.multiphasicapps.markdownwriter.MarkdownWriter;
import net.multiphasicapps.squirreljme.java.symbols.BinaryNameSymbol;
import net.multiphasicapps.squirreljme.java.symbols.ClassNameSymbol;
import net.multiphasicapps.squirreljme.java.symbols.IdentifierSymbol;
import net.multiphasicapps.util.sorted.SortedTreeMap;

/**
 * This loads the class doclet documentation and obtains information so that
 * it may be neatly output.
 *
 * @since 2016/09/13
 */
public class MarkdocClass
	extends CommondocClass
{
	/**
	 * {@squirreljme.property net.multiphasicapps.doclet.markdown.debug=(bool)
	 * If this is set to {@code true} then the output generated by the doclet
	 * is also printed to standard output for debugging purposes.}
	 */
	private static final boolean _DEBUG_OUTPUT =
		Boolean.getBoolean("net.multiphasicapps.doclet.markdown.debug");
	
	/** The base path for the markdown file. */
	protected final Path basemarkdownpath;
	
	/**
	 * Initializes the wrapped markdown class.
	 *
	 * @param __dm The main doclet.
	 * @param __cd The class documentation.
	 * @since 2016/10/11
	 */
	public MarkdocClass(MarkdocMain __dm, ClassDoc __cd)
	{
		super(__dm, __cd);
		
		// Setup name for markdown file location
		Path p = this.basenamepath;
		this.basemarkdownpath = __lowerPath(
			p.resolveSibling(p.getFileName() + ".mkd"));
	}
	
	/**
	 * The path to the markdown file.
	 *
	 * @return The markdown path.
	 * @since 2016/10/01
	 */
	public Path markdownPath()
	{
		return this.basemarkdownpath;
	}
	
	/**
	 * Writes the class documentation details to the output markdown file.
	 *
	 * @since 2016/09/13
	 */
	public void writeOutput()
	{
		// Get main
		MarkdocMain main = (MarkdocMain)this.main;
		
		// Determine
		Path makemark = main.outputPath(this.basemarkdownpath);
		
		// Need to create directories
		try
		{
			Files.createDirectories(makemark.getParent());
		}
		
		// {@squirreljme.error CF05 Could not create directories for files.}
		catch (IOException e)
		{
			throw new RuntimeException("CF05", e);
		}
		
		// Setup output
		try (MarkdownWriter md = new MarkdownWriter(__wrap(
			new OutputStreamWriter(
			Channels.newOutputStream(FileChannel.open(makemark,
			StandardOpenOption.CREATE_NEW, StandardOpenOption.WRITE))))))
		{
			// Top level header
			String qualifiedname = this.qualifiedname;
			md.header(true, 1, qualifiedname);
			
			// Description of the class
			md.header(true, 2, "Description");
			
			// Describe the class
			ClassDoc doc = this.doc;
			__writeDocFormatted(md, doc.commentText());
			
			// Fields
			md.header(true, 2, "Fields");
			
			// Methods
			md.header(true, 2, "Methods");
			
			// Write class tree last
			md.header(true, 2, "Inheritance");
			
			/*
			// Start inheritence list tree
			md.listStart();
			boolean inhnext = false;
			
			// Print super class, if there is one
			MarkdocClass superclass = (MarkdocClass)this.superclass;
			if (superclass != null)
			{
				// Go go next item?
				if (inhnext)
					md.listNext();
				inhnext = true;
				
				// Print it
				md.print("Superclass: ");
				md.uri(main.uriToClassMarkdown(this, superclass),
					superclass.unqualifiedName());
			}
			
			// Print implemented interfaces
			Collection<MarkdocClass> implints = this.interfaces.values();
			if (!implints.isEmpty())
			{
				// Next item?
				if (inhnext)
					md.listNext();
				inhnext = true;
				
				// List group title
				md.print("Implements:");
				
				// Enter a new list
				md.listStart();
				boolean ilnext = false;
				
				// Print interfaces
				for (MarkdocClass in : implints)
				{
					// Next?
					if (ilnext)
						md.listNext();
					ilnext = true;
					
					// Link to it
					md.uri(main.uriToClassMarkdown(this, in),
						in.unqualifiedName());
				}
				
				// End it
				md.listEnd();
			}
			
			// Classes which extend this class
			Collection<MarkdocClass> scoflist = this.superclassof.values();
			if (!scoflist.isEmpty())
			{
				// Next item?
				if (inhnext)
					md.listNext();
				inhnext = true;
				
				// Group title
				md.print("Superclass of:");
				
				// Indent some more
				md.listStart();	
				boolean sconext = false;
				
				// Go through all superclases (for this project only)
				for (MarkdocClass scof : scoflist)
				{
					// Next item?
					if (sconext)
						md.listNext();
					sconext = true;
					
					// Link to it
					md.uri(main.uriToClassMarkdown(this, scof),
						scof.unqualifiedName());
				}
				
				// End
				md.listEnd();
			}
			
			// Classes which implement this class
			Collection<MarkdocClass> icoflist = this.interfacesof.values();
			if (!icoflist.isEmpty())
			{
				// Next item?
				if (inhnext)
					md.listNext();
				inhnext = true;
				
				// Group title
				md.print("Implemented by:");
				
				// Indent some more
				md.listStart();	
				boolean iconext = false;
				
				// Go through all interfaces (for this project only)
				for (MarkdocClass icof : icoflist)
				{
					// Next item?
					if (iconext)
						md.listNext();
					iconext = true;
					
					// Link to it
					md.uri(main.uriToClassMarkdown(this, icof),
						icof.unqualifiedName());
				}
				
				// End
				md.listEnd();
			}
			
			// Stop list
			md.listEnd();
			*/
			
			// Flush
			md.flush();
		}
		
		// {@squirreljme.error CF03 Could not write the output markdown file.}
		catch (RuntimeException|Error|IOException e)
		{
			// Delete the output
			try
			{
				Files.delete(makemark);
			}
			
			// Ignore
			catch (IOException f)
			{
			}
			
			// Throw as is or wrap?
			if (e instanceof RuntimeException)
				throw (RuntimeException)e;
			else if (e instanceof Error)
				throw (Error)e;
			else
				throw new RuntimeException("CF03", e);
		}
		
		// End marker?
		if (_DEBUG_OUTPUT)
			System.out.println("\n------------------------------------------");
	}
	
	/**
	 * Lowercases the entire path set.
	 *
	 * @param __p The path to lowercase.
	 * @return The lowercase form of the path.
	 * @throws NullPointerException On null arguments.
	 * @since 2016/09/13
	 */
	static Path __lowerPath(Path __p)
		throws NullPointerException
	{
		// Check
		if (__p == null)
			throw new NullPointerException("NARG");
		
		// Add lowercase forms
		List<String> bnp = new ArrayList<>();
		for (Path p : __p)
			bnp.add(__lowerString(p.toString()));
		
		// Rebuild
		return Paths.get(bnp.remove(0),
			bnp.<String>toArray(new String[bnp.size()]));
	}
	
	/**
	 * Lowercases the specified string and replaces out of range characters
	 * with escaped symbols.
	 *
	 * @param __s The string to lowercase.
	 * @return The string lowercased in pure ASCII.
	 * @throws NullPointerException On null arguments.
	 * @since 2016/09/13
	 */
	static String __lowerString(String __s)
		throws NullPointerException
	{
		// Check
		if (__s == null)
			throw new NullPointerException("NARG");
		
		// Build
		StringBuilder sb = new StringBuilder();
		int n = __s.length();
		for (int i = 0; i < n; i++)
		{
			char c = __s.charAt(i);
			
			// Funny character?
			if (!(c == '.' || c == '_' || (c >= '0' && c <= '9') ||
				(c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')))
			{
				sb.append('_');
				sb.append(String.format("%04x", c & 0xFFFF));
			}
			
			// Lower?
			else if (c >= 'A' && c <= 'Z')
				sb.append((char)('a' + (c - 'A')));
				
			// same
			else
				sb.append(c);
		}
		
		// Return
		return sb.toString();
	}
	
	/**
	 * Potentially wraps the given appendable with another that prints to
	 * standard output and forwards.
	 *
	 * @param __a The appendable to forward to.
	 * @return Either {@code __a} or a wrapped appendable that also appends to
	 * standard output.
	 * @throws NullPointerException On null arguments.
	 * @since 2016/10/02
	 */
	static Appendable __wrap(Appendable __a)
		throws NullPointerException
	{
		// Check
		if (__a == null)
			throw new NullPointerException("NARG");
		
		// Wrap it?
		if (_DEBUG_OUTPUT)
			return new __AppendToStdOut__(__a);
		return __a;
	}
	
	/**
	 * Writes formatted document text.
	 *
	 * @param __md The target writer.
	 * @param __text The text to write.
	 * @throws IOException On write errors.
	 * @throws NullPointerException If no writer was specified.
	 * @since 2016/10/02
	 */
	static void __writeDocFormatted(MarkdownWriter __md, String __text)
		throws IOException, NullPointerException
	{
		// Check
		if (__md == null)
			throw new NullPointerException("NARG");
		
		// Write nothing if there is nothing.
		if (__text == null || __text.length() <= 0)
		{
			__md.print("No description.");
			return;
		}
		
		// Write all characters
		int n = __text.length();
		for (int i = 0; i < n; i++)
		{
			char c = __text.charAt(i);
			
			// Print it normally
			__md.print(c);
		}
	}
}

